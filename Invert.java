/*
********************************************************************************
* 01.07.1995   Пакет программ решения разреженных линейных систем              *
*              уравнений большой размерности с симметричной матрицей           *
* 10.11.2018   Переведено в Java                                               *
*                                                       Поляченко Дм.   МФТИ   *
********************************************************************************
* Функции пакета (более подробно см. документацию пакета):                     *
* invert()    -    Производит разложение передаваемой матрицы и итерационное   *
*                  уточнение решения. Используется, когда нужно один раз вы-   *
*                  числить решение уравнения для одного вектора правой части   *
* factorize() -    Производит разложение передаваемой  матрицы  и  cохраняет   *
*                  разложение  в передаваемых массивах.  Используется  перед   *
*                  вызовом итерационных функций и/или функции solve()          *
* solve() -        Вычисляет произведение  вектора  на матрицу,  обратную  к   *
*                  разложенной. Разложение должно быть предварительно произ-   *
*                  ведено вызовом функции factorize(). Если передать в функ-   *
*                  цию вектор правой части, получим приближенное решение ис-   *
*                  xодного уравнения. Cтепень точности  решения  зависит  от   *
*                  точности разложения  матрицы  ( барьера малых элементов )   *
*                  функциeй factorize().  Функция  может  использоваться при   *
*                  программировании новых итерационных алгоритмов              *
* iterations() -   Производит итерационное вычисление решения методом  прос-   *
*                  тых итераций. Разложение должно быть предварительно  про-   *
*                  ведено вызовом функции factorize().                         *
* iterations1() -  Производит итерационное вычисление решения  методом  наи-   *
*                  меньших квадратов. Разложение должно быть предварительно    *
*                  проведено вызовом функции factorize().                      *
* iterations2() -  Производит итерационное вычисление решения  методом  наи-   *
*                  меньших квадратов с ускорением по двум направлениям. Раз-   *
*                  ложение должно быть  предварительно  произведено  вызовом   *
*                  функции factorize().  Наиболее быстрая процедура из трех.   *
* A_by_vector() -  Функция умножения вектора на матрицу. Может использовать-   *
*                  при разработке каких-либо пользовательских процедур.        *
* norm_vec() -     Функция вычисления  евклидовой нормы  вектора.  Может ис-   *
*                  пользоваться при разработке процедур пользователя.          *
* ext_norm_vec() - Функция вычисления матричной нормы вектора. Может исполь-   *
*                  зоваться при разработке процедур пользователя.              *
*******************************************************************************/
package advancedmedia;

public class Invert {

    // Глобальные переменные для хранения структуры исходной матрицы (передаются)
    private double[] a0;        // содержит элементы исходной матрицы (построчно)
    private int[] cn0;          // содержит столбцовые индексы элементов матрицы
    private int[] pnt0_0;       // указывают на местоположения строк матрицы
    private int[] pnt0_1;       // в массивах  a0  и  cn0

    // Глобальные переменные для хранения разложенной матрицы (передаются)
    private double[] a;         // массив, в котором проводится разложение;в начале процедуры содержит элементы исходной
                                // матрицы (кроме диагональных), в конце - элементы ортогональных матриц разложения
    private int[] cn;           // содержит столбцовые индексы соответствующих элементов матрицы в массиве a (строчный список)
    private int[] pnt_0;        // указывают на расположение строк матриц
    private int[] pnt_1;        // в массивах  a  и  cn

    private int[] ln;           // содержит строчные индексы элементов активной подматрицы сгруппированных по столбцам без ссылок
                                // на сами элементы (столбцовый список)
    private int[] pnt_2;        // указывают на расположение столбцов
    private int[] pnt_3;        // подматрицы в массиве  ln

    private double[] diag;      // диагональные элементы исходной матрицы в начале разложения, элементы диагональной матрицы разложения - в конце
    private int[] s;            // матрицы перестановок

    private int n;              // размер матрицы
    private double t;           // барьер
    private double t2;          // квадрат барьера (для "безразмерной" процедуры обнуления малых элементов )
    private double delta;       // предельно допустимая близость к нулю элементов диагональной матрицы разложения
    private int p;              // число вакантных мест, оставляемых незаполненными при перезаписи строк и столбцов

    // Служебные переменные и массивы для процедур разложения и итерационного уточнения (аллокируются программой при входе и освобождаются при выходе)
    private int[] price;        // массив, содержащий веса диагональных элементов
    private int[] rings1;       // кольцевые списки диаг. эл-ов одного веса
    private int[] rings2;       // кольц. списки, связанные в обратном направлении
    private int[] ring_adr;     // точки входа в кольцевые списки диаг. элементов, имеющих одинаковый вес
    private int[] vac_0;        // сколько своб. мест в строке матрицы
    private int[] vac_1;        // ------------------ в столбце матрицы

    private int[] index;        // cлужебн. массив индексов элементов матрицы, используется в разложении
    private double[] tmpr;      // cлужебн. массив, используется в разложении
    private int[] arr_mas;      // cлужебн. массивы, исп. при сборках мусора
    private int[] lc;

    private int cn_end;         // число использованных элементов массивов a и cn
    private int ln_end;         // число использованных элементов массивa ln
    private int cn_len;         // длина массивов a и cn
    private int ln_len;         // длина массивa ln
    private int step;           // шаг разложения матрицы

    private int arr_cn_num;     // число перезаписей строк в конец списка
    private int arr_ln_num;     // число перезаписей столбцов в конец списка
    private int rwr_cn_num;     // число сборок мусора по строчному списку
    private int rwr_ln_num;     // число сборок мусора по столбцовому списку

    private int num_iter;       // число итераций

    // Коды возврата
    final private int OK = 0;                        // OK
    final private int NO_SATISFIED_ACCURACY = 1;     // Требуемая точность не достигнута, хотя итер. процесс не расходится
    final private int MEMORY_LACK = 2;               // Нехватка памяти при попытке захватить память для служебных массивов
    final private int INVALID_ACTUAL_PARAM = 3;      // Передача неправильного параметра
    final private int NULL_POINTER_TRANSMISSION = 4; // В функцию передан нулевой указатель
    final private int TOO_LARGE_INDEX = 5;           // Проверка выявила элемент, имеющий слишком большой столбцовый индекс
    final private int TWO_EQUAL_ELEM_INDEXES = 6;    // Проверка выявила элементы одной строки, имеющие один и тот же столбцовый индекс
    final private int ITER_PROCESS_DIVERGENCE = 7;   // Итерационный процесс расходится
    final private int BAD_MATRIX = 8;                // Матрица плохо обусловлена
    final private int TOO_FEW_ROOM_cn_MAS = 9;       // Не хватает места в строчно-упорядоченном массиве, т.е. переданные функции массивы a и cn малы
    final private int TOO_FEW_ROOM_ln_MAS = 10;      // Не хватает места в столбцово-упорядоченном массиве, т.е. переданный функции массив rn мал

    // Внутренние коды возврата
    final private int CN_ARRANGEMENT_DONE = 15;

    final private double RAT = 1.2;                  // Kритическое отношение полного размера массивов к числу заполненных элементов
    final private int NUM_ELEM_SEARCH = 5;           // Число просматриваемых элементов в процедуре выбора главного элемента
    final private int DIVER_PARAM = 10;              // Число подряд расходящихся итераций до прекращения итерационного процесса

    /*
    ****************************************************************************
    *                       Пользовательские функции                          
    ****************************************************************************/
    //  Функция вычисления решения уравнения Ax = b (A - симметричная матрица).
    //  Разлагает A в произведение матриц и итерационной процедурой получает решение
    public int invert(
            // Параметры для процедуры разложения 
            int _n, // размер матрицы
            int _p, // параметр, опред. сколько элементов резервировать в каждой  строке  строчно-упорядоченного  списка и в
            // каждом  столбце  столбцово-упорядоченного  списка
            double _t, // барьер (параметр, по которому происходит отбрасывание малых элементов при факторизации)
            double[] _a0, // массив, содержащий элементы матрицы
            int[] _cn0, // массив, содержащий cтолбцовые индексы
            int[] _pnt0_0, // массив длины _n, сод. индексы начала строк в _a0,_cn0
            int[] _pnt0_1, // массив длины _n, сод. индексы конца строк в _a0,_cn0

            double[] _a, // массив, в который будут занесенынедиагональные элементы ортог. матриц разложения
            int[] _cn, // массив, содержащий в конце разложения столбцовые индексы соотв. элементов массива _a
            int _cn_len, // количество элем. в массивах  _a  и  _cn (должно быть в несколько раз больше числа элем. исходной матрицы - подбирается экспериментально)
            int[] _pnt_0, // массив длины _n, в который будут занесены индексы начала строк ортогон. матриц в массивах _a,_cn
            int[] _pnt_1, // массив длины _n, в который будут занесены индексы конца строк ортогон. матриц в массивах _a,_cn

            int[] _ln, // массив, содержащий в процессе разложения столбцово-упорядоченный список; после разложения полезной информации не несет
            int _ln_len, // количество элементов в массиве _ln
            int[] _pnt_2, // массив длины _n, в который заносятся индексы начала столбцов активной подматрицы в массиве _ln
            int[] _pnt_3, // массив длины _n, в который заносятся индексы конца столбцов активной подматрицы в массиве _ln;
            // оба массива используются только внутри функции и могут быть удалены после разложения

            double[] _diag, // массив, в который будут занесены элементы диагональной матрицы разложения
            int[] _s, // массив, в который будет записана информация о матрицах перестановок
            double _delta, // минимально допустимое отличие от нуля элементов диагональной матрицы разложения; при нарушении 
            // этого условия возвращается код ошибки, соотв. плохой обусловленности матрицы 

            // Параметры для процедуры итер.уточнения 
            double[] _b, // м-в , сод. элементы вектора правой части ур-я
            double[] _x, // м-в , в к-й записывается решение
            double _eps, // точность итераций 
            int _maxit, // максимальное число итераций 
            int _method) // итерациoнный метод: 0 - метод простых итераций, 1 - метод наименьших квадратов, 
    {                       // 2 - метод наименьших квадратов c ускорением
        int ret_value;

        ret_value = factorize(_n, _p, _t, _a0, _cn0, _pnt0_0, _pnt0_1,
                _a, _cn, _cn_len, _pnt_0, _pnt_1, _ln, _ln_len, _pnt_2, _pnt_3,
                _diag, _s, _delta);

        if (ret_value != OK) // Неудача, возвращаем код ошибки
        {
            return ret_value;
        }

        switch (_method) {
            case 0:
                ret_value = iterations(_n, _a0, _cn0, _pnt0_0, _pnt0_1,
                        _a, _cn, _pnt_0, _pnt_1, _diag, _s,
                        _b, _x, _eps, _maxit);
                break;

            case 1:
                ret_value = iterations1(_n, _a0, _cn0, _pnt0_0, _pnt0_1,
                        _a, _cn, _pnt_0, _pnt_1, _diag, _s,
                        _b, _x, _eps, _maxit);
                break;

            case 2:
                ret_value = iterations2(_n, _a0, _cn0, _pnt0_0, _pnt0_1,
                        _a, _cn, _pnt_0, _pnt_1, _diag, _s,
                        _b, _x, _eps, _maxit);
                break;

            default:
                return INVALID_ACTUAL_PARAM;
        }
        return ret_value;
    }

    /*
    ****************************************************************************
    * Функция разложения симметричной матрицы в произведение матриц:        
    *        т                                                               
    *   A = L B L, где B - диагональная матрица,  L - ортогональная и
    *              представляется в виде: L = L    S   ... L  S
    *                                          n-1  n-1     1  1
    *  (более подробно - см. документацию к программе)
    ***************************************************************************/
    //  Запрашивает память для служебных массивов, вызывает функцию fill_mas() для их инициализации, 
    // затем вызывает функцию factorization() (непосредственно разложение за n шагов)
    public int factorize( // Прототип функции разложения матрицы (вычисление x не производится - только разложение и заполнение соотв. массивов)
            int _n, // размер матрицы
            int _p, // параметр, опред. сколько элементов резервировать в каждой  строке  строчно-упорядоченного  списка и в
            // каждом  столбце  столбцово-упорядоченного  списка
            double _t, // барьер (параметр, по которому происходит отбрасывание малых элементов при факторизации)
            double[] _a0, // массив, содержащий элементы матрицы
            int[] _cn0, // массив, содержащий cтолбцовые индексы
            int[] _pnt0_0, // массив длины _n, сод. индексы начала строк в _a0,_cn0
            int[] _pnt0_1, // массив длины _n, сод. индексы конца строк в _a0,_cn0

            double[] _a, // массив, в который будут занесенынедиагональные элементы ортог. матриц разложения
            int[] _cn, // массив, содержащий в конце разложения столбцовые индексы соотв. элементов массива _a
            int _cn_len, // количество элем. в массивах  _a  и  _cn (должно быть в несколько раз больше числа элем. исходной матрицы - подбирается экспериментально)
            int[] _pnt_0, // массив длины _n, в который будут занесены индексы начала строк ортогон. матриц в массивах _a,_cn
            int[] _pnt_1, // массив длины _n, в который будут занесены индексы конца строк ортогон. матриц в массивах _a,_cn

            int[] _ln, // массив, содержащий в процессе разложения столбцово-упорядоченный список; после разложения полезной информации не несет
            int _ln_len, // количество элементов в массиве _ln
            int[] _pnt_2, // массив длины _n, в который заносятся индексы начала столбцов активной подматрицы в массиве _ln
            int[] _pnt_3, // массив длины _n, в который заносятся индексы конца столбцов активной подматрицы в массиве _ln;
            // оба массива используются только внутри функции и могут быть удалены после разложения

            double[] _diag, // массив, в который будут занесены элементы диагональной матрицы разложения
            int[] _s, // массив, в который будет записана информация о матрицах перестановок
            double _delta) { // минимально допустимое отличие от нуля элементов диагональной матрицы разложения; при нарушении этого условия возвращается код ошибки, соотв. плохой обусловленности матрицы

        int ret_value;
        int num_elements = 0;

        n = _n;                      // Инициализация глобальных переменных
        p = _p;
        t = _t;
        t2 = t * t;
        delta = _delta;

        if ((_a0 == null) || (_cn0 == null)
                || // Проверка на нулевой указатель
                (_pnt0_0 == null) || (_pnt0_1 == null)) {
            return NULL_POINTER_TRANSMISSION;
        }

        for (int i = 1; i <= n; i++) // Подсчет числа элементов
        {
            num_elements += (_pnt0_1[i] - _pnt0_0[i]);
        }

        if (num_elements + p * n >= (long) (_cn_len / RAT)) // Eсли мало места в массивах,
        {
            return TOO_FEW_ROOM_cn_MAS;         // выход с кодом возврата
        }
        if (num_elements + p * n >= (long) (_ln_len / RAT)) {
            return TOO_FEW_ROOM_ln_MAS;
        }

        a0 = _a0;                    // Инициализация указателей глобальных массивов,
        cn0 = _cn0;                  // cодержащих исходную матрицу
        pnt0_0 = _pnt0_0;
        pnt0_1 = _pnt0_1;

        if ((_a == null) || (_cn == null)
                || // Проверка на нулевой указатель
                (_pnt_0 == null) || (_pnt_1 == null)) {
            return NULL_POINTER_TRANSMISSION;
        }
        a = _a;                      // Инициализация указателей глобальных массивов
        cn = _cn;                    // для размещения факторизованной матрицы
        pnt_0 = _pnt_0;
        pnt_1 = _pnt_1;
        cn_len = _cn_len;

        // Проверка на нулевой указатель
        if ((_ln == null) || (_pnt_2 == null) || (_pnt_3 == null)) {
            return NULL_POINTER_TRANSMISSION;
        }
        ln = _ln;                    // Инициализация указателей глобальных массивов
        pnt_2 = _pnt_2;              // для разм. столбцово-упорядоченного списка
        pnt_3 = _pnt_3;
        ln_len = _ln_len;

        if ((_diag == null) || (_s == null)) {
            return NULL_POINTER_TRANSMISSION;
        }
        diag = _diag;                // Диагональная матрица разложения
        s = _s;                      // Матрицы перестановок

        arr_ln_num = arr_cn_num = 0;
        rwr_ln_num = rwr_cn_num = 0;

        //  Запрос памяти для служебных  массивов
        price = new int[n + 1];
        if (price == null) {
            return MEMORY_LACK;
        }

        rings1 = new int[n + 1];
        if (rings1 == null) {
            return MEMORY_LACK;
        }

        rings2 = new int[n + 1];
        if (rings2 == null) {
            return MEMORY_LACK;
        }

        ring_adr = new int[n + 1];
        if (ring_adr == null) {
            return MEMORY_LACK;
        }

        vac_0 = new int[n + 1];
        if (vac_0 == null) {
            return MEMORY_LACK;
        }

        vac_1 = new int[n + 1];
        if (vac_1 == null) {
            return MEMORY_LACK;
        }

        index = new int[n + 1];;
        if (index == null) {
            return MEMORY_LACK;
        }

        tmpr = new double[n + 1];
        if (tmpr == null) {
            return MEMORY_LACK;
        }

        arr_mas = new int[n + 1];
        if (arr_mas == null) {
            return MEMORY_LACK;
        }

        lc = new int[n + 1];
        if (lc == null) {
            return MEMORY_LACK;
        }

        ret_value = fill_mas();     // Инициализируем служебные массивы

        if (ret_value != OK) // В случае неудачи (возвращаемое значение != 0) освобождаем захваченную память и выходим с кодом ошибки
        {
            return ret_value;
        }

        ret_value = factorization();   // Непосредственно процедура разложения матрицы

        return ret_value;
    }

    //  Функция обращения факторизованной матрицы (точнее, операции
    //  умножения вектора на обратную к ней, см. документацию к программе)
    //  Вся процедура укладывается в 2n шагов. Для решения исходного уравнения
    //     _      1 1 2 2       n-1 n-1      n-1 n-1       2 2 1 1
    //     Ax = (S L'S L'..... S   L'   B   L   S   ..... L S L S )x = b
    //
    //                                1 1  1                 2 2  2    1
    //   на первом шаге решается ур. S L' x  = b, на втором S L' x  = x  и т.д.
    //
    //   Функция может использоваться при реализации новых итерац. алгоритмов
    //   Не вызывает никаких вспомогательных функций
    
    public int solve(
            int _n, // Размер матрицы
            double[] _a, // Массив, в который занесены недиагональные элементы ортогогональных матриц разложения
            int[] _cn, // Массив, столбцовые индексы соотв. элементов массива _a  (после вызова factorize())
            int[] _pnt_0, // Массив длины _n, в котором находятся индексы начала строк ортогон. матриц в массивах _a,_cn
            int[] _pnt_1, // Массив длины _n, в котором находятся индексы конца строк ортогон. матриц в массивах _a,_cn
            double[] _diag, // Массив длины _n, в котором находятся элементы диагональной матрицы разложения
            int[] _s, // Массив, содержащий матрицы перестановок
            double[] _b, // Массив, сод. элементы вектора правой части ур-я
            double[] _x) {  // Массив, в к-й записывается результат

        double buf;

        for (step = 1; step <= _n; step++)      // Инициализируем _x правой частью
        {
            _x[step] = _b[step];
        }

        for (step = 1; step < _n; step++)       // Решение уравнения  SLy = b
        {
            int j = _s[step];                                            
            buf = _x[step];                     // Cначала умножаем уравнение на S
            _x[step] = _x[j];
            _x[j] = buf;
            
            for (int i = _pnt_0[step] + 1; i <= _pnt_1[step]; i++) {    // Затем обращаем матрицу L
                _x[_cn[i]] -= _x[step] * _a[i];
            }
        }

        for (int j = 1; j <= _n; j++) {         // Решение уравнения  Bz = y
            _x[j] /= _diag[j];            
        }

        for (step = _n - 1; step >= 1; step--)  // Решение уравнения  LSx = z
        {
            for (int i = _pnt_0[step] + 1;      // Cначала обращаем матрицу L
                    i <= _pnt_1[step]; i++) {
                _x[step] -= _x[_cn[i]] * _a[i];
            }

            int j = _s[step];
            buf = _x[step];                     // Затем умножаем уравнение на S
            _x[step] = _x[j];
            _x[j] = buf;
        }
        return OK;
    }

    /*
    ****************************************************************************
    * Итерационная процедура по методу простых итераций с использованием
    * разложения исходной матрицы.
    * При входе аллокирует буферный массив. Использует функции solve() 
    * (для вычисления поправок), A_by_vector() (для умножения векторов) 
    * и norm_vec() для вычисления норм векторов    
    ****************************************************************************
    * ╔═══════════════════════════════════════════════════════════════════════════╗
    * ║ Алгоритм итер. уточнения методом простой итерации ║
    * ╟─────────────────────────────────────┬─────────────────────────────────────╢
    * ║ 1 _-1 │ i+1 i i ║ ║ 1: x = A b   <ф-я solve()> │ 5: x = x + d ║
    * ╟─────────────────────────────────────┼─────────────────────────────────────╢     
    * ║ i i │ ║ ║ 2: r = b - A x │ 6: i < maxit goto 2 ║
    * ╟─────────────────────────────────────┼─────────────────────────────────────╢
    * ║ i │ ║ ║ ║ r ║ │ ║ ║ 3: ─────── <=eps goto 7 │ 7: конец итераций ║ ║ ║b║
    * │ ║
    * ╟─────────────────────────────────────┼─────────────────────────────────────╢
    * ║ i _-1 i │ ║ ║ 4: d = A r │ ║
    * ╚═════════════════════════════════════╧═════════════════════════════════════╝
     */
    public int iterations( //  Функция итерационного уточнения методом простых итераций с использованием разложения исходной матрицы
            // Массивы, содержащие исходную матрицу
            int _n, // размер матрицы
            double[] _a0, // массив, содержащий элементы матрицы
            int[] _cn0, // массив, содержащий cтолбцовые индексы
            int[] _pnt0_0, // м-в длины _n, сод. индексы начала строк в _a0,_cn0
            int[] _pnt0_1, // м-в длины _n, сод. индексы конца строк в _a0,_cn0

            // Массивы, содержащие факторизованную матрицу (должны быть уже заполнены после успешного вызова factorize())
            double[] _a, // массив, в который занесены недиагональные элем. ортог. матриц разложения (заполняется функцией factorize())
            int[] _cn, // массив, содержащий в конце разложения столбцовые индексы соотв. элементов массива _a (после вызова функции factorize() или invert())
            int[] _pnt_0, // массив длины _n+1, в который занесены индексы начала строк ортогон. матриц в массивах _a,_cn (после factorize())
            int[] _pnt_1, // массив длины _n+1, в который занесены индексы конца строк ортогон. матриц в массивах _a,_cn (после factorize())
            double[] _diag, // массив, в который занесены элементы диагональной матрицы разложения (после factorize())
            int[] _s, // массив, в который записана информация о матрицах перестановок (после factorize())

            // Правая часть уравнения
            double[] _b, // массив, содержащий элементы вектора правой части ур-я

            // Аллокированный заранее массив, куда будет записано решение
            double[] _x, // массив, в которыйй записывается решение

            // Остальные параметры
            double _eps, // точность итераций
            int _maxit) {   // максимальное число итераций

        int diver_num;
        double b_norm, r_norm;
        double[] r_vect;

        num_iter = 0;
        diver_num = 0;

        r_norm = Double.MAX_VALUE;

        r_vect = new double[n + 1];                                     // Память под временный массив
        if (r_vect == null) {
            return MEMORY_LACK;
        }

        norm_vec(_n, _b);                                               // Вычисление нормы правой части
        b_norm = _b[0];

        solve(_n, _a, _cn, _pnt_0, _pnt_1, _diag, _s, _b, _x);          // Вычислить нач. приближение

        while (num_iter < _maxit) {
            
            A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, _x, r_vect);   // Вычисление невязки

            for (int i = 1; i <= _n; i++) {
                r_vect[i] -= _b[i];
            }

            norm_vec(_n, r_vect);                                       // Вычисление нормы

            if (r_norm < r_vect[0]) // Проверка на расходимость
            {
                if (++diver_num >= DIVER_PARAM) {
                    return ITER_PROCESS_DIVERGENCE;
                }
            } else {
                diver_num = 0;
            }

            r_norm = r_vect[0];                                         // Сoхранить значение нормы до  следующей  итерации

            if (r_norm <= _eps * b_norm)                                // Проверка достижения точности
            {
                _x[0] = r_norm / b_norm;                                // Нулевой элемент вектора решения cодержит значение ║Ax-b║/║b║
                return OK;
            }

            solve(_n, _a, _cn, _pnt_0, _pnt_1, _diag, _s, r_vect, r_vect);  // Вычислить новое приближение

            for (int i = 1; i <= _n; i++) {
                _x[i] -= r_vect[i];
            }
            num_iter++;
        }

        _x[0] = r_norm / b_norm;                // Нулевой элемент вектора решения cодержит значение ║Ax-b║/║b║

        return NO_SATISFIED_ACCURACY;           // Процесс сходится, но точность _eps не достигнута
    }

    /*
    * ***********************************************************************
    * Итерационная процедура по методу наименьших квадратов с * использованием
    * разложения исходной матрицы *
    * ************************************************************************
    * Oпределение функции итерационного уточнения методом наименьших
    * квадратов // с использованием разложения исходной матрицы // Функция
    * реализует описанный выше (перед декларацией функции) алгоритм // итер.
    * уточнения. При входе аллокирует буферные массивы, которые //
    * освобождаются перед возвратом из функции. // Использует функции solve()
    * (для вычисления поправок), // A_by_vector() (для умножения векторa на
    * матрицу задачи) и // norm_vec() для вычисления норм векторов
    *
    * ╔═══════════════════════════════════════════════════════════════════════════╗
    * ║ Алгоритм итер. уточнения методом наименьших квадратов ║
    * ╟─────────────────────────────────────┬─────────────────────────────────────╢
    * ║ 1 _-1 │ i _-1 i ║ ║ 1: x = A b   <ф-я solve()> │ 5: d = A r ║ ║ │ ║
    * ╟─────────────────────────────────────┼─────────────────────────────────────╢
    * ║ i i │ i+1 i i i ║ ║ 2: r = b - A x │ 6: x = x + t d ║ ║ i │ ║
    * ╟─────────────────────────────────────┼─────────────────────────────────────╢
    * ║ i │ ║ ║ ║ r ║ │ ║ ║ 3: ─────── <=eps goto 8 │ 7: i < maxit goto 2 ║ ║
    * ║b║ │ ║
    * ╟─────────────────────────────────────┼─────────────────────────────────────╢
    * ║ _-1 i i │ ║ ║ i (A A r , r ) │ ║ ║ 4: t = - ───────────── │ 8: конец
    * итераций ║ ║ ║ _-1 i║ 2 │ ║ ║ ║ A A r ║ │ ║
    * ╚═════════════════════════════════════╧═════════════════════════════════════╝
     */
    // Параметры идентичны параметрам функции iterations()
    public int iterations1( // Функция итерационного вычисления решения методом наименьших квадратов
            // Массивы, содержащие исходную матрицу
            int _n, // размер матрицы
            double[] _a0, // массив, содержащий элементы матрицы
            int[] _cn0, // массив, содержащий cтолбцовые индексы
            int[] _pnt0_0, // м-в длины _n, сод. индексы начала строк в _a0,_cn0
            int[] _pnt0_1, // м-в длины _n, сод. индексы конца строк в _a0,_cn0

            // Массивы, содержащие факторизованную матрицу (должны быть уже заполнены после успешного вызова factorize())
            double[] _a, // массив, в который занесены недиагональные элем. ортог. матриц разложения (заполняется функцией factorize())
            int[] _cn, // массив, содержащий в конце разложения столбцовые индексы соотв. элементов массива _a (после вызова функции factorize() или invert())
            int[] _pnt_0, // массив длины _n+1, в который занесены индексы начала строк ортогон. матриц в массивах _a,_cn (после factorize())
            int[] _pnt_1, // массив длины _n+1, в который занесены индексы конца строк ортогон. матриц в массивах _a,_cn (после factorize())
            double[] _diag, // массив, в который занесены элементы диагональной матрицы разложения (после factorize())
            int[] _s, // массив, в который записана информация о матрицах перестановок (после factorize())

            // Правая часть уравнения
            double[] _b, // массив, содержащий элементы вектора правой части ур-я

            // Аллокированный заранее массив, куда будет записано решение
            double[] _x, // массив, в которыйй записывается решение

            // Остальные параметры
            double _eps, // точность итераций
            int _maxit) {        // максимальное число итераций

        int diver_num;
        double b_norm, r_norm;
        double tau, denom;
        double[] r_vect;
        double[] d_vect;
        double[] Ad_vect;

        num_iter = 0;
        diver_num = 0;

        r_norm = Double.MAX_VALUE;

        norm_vec(_n, _b);                                               // Вычисление нормы правой части
        b_norm = _b[0];

        solve(_n, _a, _cn, _pnt_0, _pnt_1, _diag, _s, _b, _x);          // Вычислить нач. приближение                

        r_vect = new double[n + 1];                                     // Память под временныe массивы
        if (r_vect == null) {
            return MEMORY_LACK;
        }

        d_vect = new double[n + 1];
        if (d_vect == null) {
            return MEMORY_LACK;
        }

        Ad_vect = new double[n + 1];
        if (Ad_vect == null) {
            return MEMORY_LACK;
        }

        while (num_iter < _maxit) {
            
            A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, _x, r_vect);   // Вычисление невязки

            for (int i = 1; i <= _n; i++) {
                r_vect[i] -= _b[i];
            }

            norm_vec(_n, r_vect);                                       // Вычисление нормы

            if (r_norm < r_vect[0]) // Проверка на расходимость
            {
                if (++diver_num >= DIVER_PARAM) {
                    return ITER_PROCESS_DIVERGENCE;
                }
            } else {
                diver_num = 0;
            }

            r_norm = r_vect[0];                                         // Сoхранить значение нормы до  следующей  итерации

            if (r_norm <= _eps * b_norm) // Проверка достижения точности
            {
                _x[0] = r_norm / b_norm;                                // Нулевой элемент вектора решения
                return OK;                                              // cодержит значение ║Ax-b║/║b║
            }

            // Вычислeние нового приближения:
            solve(_n, _a, _cn, _pnt_0, _pnt_1, _diag, _s, r_vect, d_vect);  // Новое направление поправки d

            A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, d_vect, Ad_vect);  // Вектор A*d                    

            tau = denom = 0.0;
            for (int i = 1; i <= _n; i++) // вычисление шага поправки
            {
                tau += Ad_vect[i] * r_vect[i];
                denom += Ad_vect[i] * Ad_vect[i];
            }
            tau /= denom;

            for (int i = 1; i <= _n; i++) // новое приближение
            {
                _x[i] -= tau * d_vect[i];
            }
            num_iter++;
        }

        _x[0] = r_norm / b_norm;                     // Нулевой элемент вектора решения cодержит значение ║Ax-b║/║b║

        return NO_SATISFIED_ACCURACY;              // Процесс сходится, но точность _eps не достигнута
    }

    /*
    ***********************************************************************************************
    * Итерационная процедура по методу наименьших квадратов с ускорением по
    * двум направлениям
    * ***********************************************************************************************
    * Функция реализует описанный ниже (перед декларацией функции) алгоритм
    * итер. уточнения. При входе аллокирует буферные массивы, которые
    * освобождаются перед возвратом из функции. Использует функции solve() (для
    * вычисления поправок), A_by_vector() (для умножения векторa на матрицу
    * задачи) и norm_vec() для вычисления норм векторов
    * ╔═══════════════════════════════════════════╗ 
    * ║ Алгоритм итер. уточнения методом наименьших квадратов с ускорением       ║
    * ╟─────────────────────────────────────┬─────╢ ║ 1 0 │ i i _i i i-1 ║ ║ 1:
    * x , d │ 7: d = t d + t d ║ ║ │ 1 2 ║
    * ╟─────────────────────┼─────────────────────╢ ║ i i │ i+1 i i ║ ║ 2: r =
    * b - A x │ 8: x = x + d ║ ║ │ ║
    * ╟─────────────────────┼─────────────────────╢ ║ i │ ║ ║ ║ r ║ │ ║ ║ 3:
    * ─────── < eps goto 10 │ 9: i < maxit goto 2 ║ ║ ║ b ║ │ ║
    * ╟────────────────────┼────────────────────╢ ║ _i _-1 i │ ║ ║ 4: d = A r │
    * 10: конец итераций ║ ║ │ ║ ╟──────────────────────────────────────────╢ ║
    * _i i-1 i-1 i _i 2 _i i ║ ║ i (Ad, Ad )(Ad , r )-║A d ║ (Ad,r ) ║ ║ 5: t =
    * ────────────────────────────────── ║ ║ 1 _i 2 _i-1 2 _i i-1 2 ║ ║ ║A d ║
    * ║ A d ║ - (Ad, Ad ) ║ ╟──────────────────────────────────────────╢ ║ _i
    * i-1 _i i i-1 2 i-1 i ║ ║ i (Ad, Ad )(Ad ,r )-║A d ║ (Ad , r ) ║ ║ 6: t =
    * ────────────────────────────────── ║ ║ 2 _i 2 _i-1 2 _i i-1 2 ║ ║ ║A d ║
    * ║ A d ║ - (Ad, Ad ) ║ ╚══════════════════════════════════════════╝
     */
    public int iterations2( // Функция итерационного вычисления решения ускоренным методом наименьших квадратов
            // Массивы, содержащие исходную матрицу
            int _n, // размер матрицы
            double[] _a0, // массив, содержащий элементы матрицы
            int[] _cn0, // массив, содержащий cтолбцовые индексы
            int[] _pnt0_0, // м-в длины _n, сод. индексы начала строк в _a0,_cn0
            int[] _pnt0_1, // м-в длины _n, сод. индексы конца строк в _a0,_cn0

            // Массивы, содержащие факторизованную матрицу (должны быть уже заполнены после успешного вызова factorize())
            double[] _a, // массив, в который занесены недиагональные элем. ортог. матриц разложения (заполняется функцией factorize())
            int[] _cn, // массив, содержащий в конце разложения столбцовые индексы соотв. элементов массива _a (после вызова функции factorize() или invert())
            int[] _pnt_0, // массив длины _n+1, в который занесены индексы начала строк ортогон. матриц в массивах _a,_cn (после factorize())
            int[] _pnt_1, // массив длины _n+1, в который занесены индексы конца строк ортогон. матриц в массивах _a,_cn (после factorize())
            double[] _diag, // массив, в который занесены элементы диагональной матрицы разложения (после factorize())
            int[] _s, // массив, в который записана информация о матрицах перестановок (после factorize())

            // Правая часть уравнения
            double[] _b, // массив, содержащий элементы вектора правой части ур-я

            // Аллокированный заранее массив, куда будет записано решение
            double[] _x, // массив, в которыйй записывается решение

            // Остальные параметры
            double _eps, // точность итераций
            int _maxit) {        // максимальное число итераций

        int diver_num;
        double b_norm, r_norm;
        double tau1, tau2;
        double[] r_vect, d_vect, d_prev;
        double[] Ad_vect, Ad_prev;
        double a, b, c, d, e;

        num_iter = 0;
        diver_num = 0;

        r_norm = Double.MAX_VALUE;

        norm_vec(_n, _b);               // Вычисление нормы правой части
        b_norm = _b[0];

        r_vect = new double[n + 1];     // Память под временныe массивы
        if (r_vect == null) {
            return MEMORY_LACK;
        }

        d_vect = new double[n + 1];
        if (d_vect == null) {
            return MEMORY_LACK;
        }

        Ad_vect = new double[n + 1];
        if (Ad_vect == null) {
            return MEMORY_LACK;
        }

        d_prev = new double[n + 1];
        if (d_prev == null) {
            return MEMORY_LACK;
        }

        Ad_prev = new double[n + 1];
        if (Ad_prev == null) {
            return MEMORY_LACK;
        }

        // Делаем нулевой шаг по мет. простых итераций (для получения предыдущего направления уточнения)
        solve(_n, _a, _cn, _pnt_0, _pnt_1, _diag, _s, _b, _x);          // Вычислить нач. приближение
        A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, _x, r_vect);       // Невязка на нулевом шаге

        for (int i = 1; i <= _n; i++) {
            r_vect[i] -= _b[i];
        }

        solve(_n, _a, _cn, _pnt_0, _pnt_1, _diag, _s, r_vect, d_prev);  // Направление поправки на нулевом шаге                     

        for (int i = 1; i <= _n; i++) {
            _x[i] -= d_prev[i];                                         // Вычисление x
        }

        while (num_iter < _maxit) {
            
            A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, _x, r_vect);   // Вычисление невязки

            for (int i = 1; i <= _n; i++) {
                r_vect[i] -= _b[i];
            }

            norm_vec(_n, r_vect);                                       // Вычисление нормы

            if (r_norm < r_vect[0]) // Проверка на расходимость
            {
                if (++diver_num >= DIVER_PARAM) {
                    return ITER_PROCESS_DIVERGENCE;
                }
            } else {
                diver_num = 0;
            }

            r_norm = r_vect[0];                                         // Сoхранить значение нормы до следующей итерации

            if (r_norm <= _eps * b_norm)                                // Проверка достижения точности
            {
                _x[0] = r_norm / b_norm;                                // Нулевой элемент вектора решения cодержит значение║Ax-b║/║b║
                return OK;
            }

            // Вычислeние нового приближения:            
            solve(_n, _a, _cn, _pnt_0, _pnt_1, _diag, _s, r_vect, d_vect);  // Вычисление вектора d = A' * r
            A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, d_vect, Ad_vect);  // Вычисление вектора A*d
            A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, d_prev, Ad_prev);  // Вычисление вектора A*d_prev
            a = b = c = d = e = 0.0;
            for (int i = 1; i <= _n; i++) {
                a += Ad_vect[i] * Ad_vect[i];           //  ║Ad║*║Ad║
                b += Ad_vect[i] * Ad_prev[i];           //  (Ad,Ad_prev)
                c += Ad_prev[i] * Ad_prev[i];           //  ║Ad_prev║*║Ad_prev║
                d -= r_vect[i] * Ad_vect[i];            //  (r,Ad)
                e -= r_vect[i] * Ad_prev[i];            //  (r,Ad_prev)
            }
            tau1 = (b * e - c * d) / (b * b - a * c);
            tau2 = (b * d - a * e) / (b * b - a * c);

            for (int i = 1; i <= _n; i++)               // Вычисление нового направления и коррекция решения
            {
                d_prev[i] = tau1 * d_vect[i] + tau2 * d_prev[i];
                _x[i] += d_prev[i];
            }
            num_iter++;
        }
        _x[0] = r_norm / b_norm;                // Нулевой элемент вектора решения cодержит значение ║Ax-b║/║b║

        return NO_SATISFIED_ACCURACY;           // Процесс сходится, но точность _eps не достигнута
    }

    /*
    ****************************************************************************
    * Функция умножения матрицы A на вектор
    ***************************************************************************/
    public int A_by_vector(
            int _n, // Размер матрицы (и векторов)
            double[] _a0, // Массив, содержащий элементы матрицы
            int[] _cn0, // Массив, содержащий cтолбцовые индексы
            int[] _pnt0_0, // М-в длины _n, сод. индексы начала строк в _a0,_cn0
            int[] _pnt0_1, // М-в длины _n, сод. индексы конца  строк в _a0,_cn0
            double[] _vector, // Умножаемый вектор
            double[] _result) { // Результат умножения

        int i, j;

        for (i = 1; i <= _n; i++) // Умножение на наддиагональную часть (включая диагональ)
        {
            _result[i] = 0.0;
            for (j = _pnt0_0[i] + 1; j <= _pnt0_1[i]; j++) {
                _result[i] += _a0[j] * _vector[_cn0[j]];
            }
        }

        for (i = 1; i <= _n; i++) // Умножение на поддиагональную часть
        {
            for (j = _pnt0_0[i] + 1; j <= _pnt0_1[i]; j++) {
                if (_cn0[j] != i) {
                    _result[_cn0[j]] += _a0[j] * _vector[i];
                }
            }
        }
        return OK;
    }

    /*
    ****************************************************************************
    * Функция вычисления евклидовой нормы вектора                            
    ***************************************************************************/
    public int norm_vec(int _n, // Длина вектора
            double[] _vector) {             // Массив из элементов вектора

        int i;
        double norm = 0.0;

        for (i = 1; i <= _n; i++) {
            norm += _vector[i] * _vector[i];
        }
        norm = Math.sqrt(norm);
        _vector[0] = norm;

        return OK;
    }

    /*
    ****************************************************************************
    * Функция вычисления вычисления расширенной евклидовой нормы вектора:   
    *            ______                                                         
    *   ║x║ = √(Ax,x)             A - симметричная матрица
    ***************************************************************************/
    public int ext_norm_vec(int _n, // размер нормирующей матрицы и вектора
            double[] _a0, // указатель на массив, содержащий элементы матрицы
            int[] _cn0, // указатель на массив, содержащий cтолбцовые индексы
            int[] _pnt0_0, // м-в длины _n, сод. индексы начала строк в _a0,_cn0
            int[] _pnt0_1, // м-в длины _n, сод. индексы конца  строк в _a0,_cn0
            double[] _vector) {  // Вектор

        double norm = 0.0;
        double[] A_vec = new double[n + 1];
        if (A_vec == null) {
            return MEMORY_LACK;
        }

        A_by_vector(_n, _a0, _cn0, _pnt0_0, _pnt0_1, _vector, A_vec);  // Вычисление вектора Ax               

        for (int i = 1; i <= _n; i++) {
            norm += _vector[i] * A_vec[i];
        }
        norm = Math.sqrt(norm);
        _vector[0] = norm;

        return OK;
    }

    /*
    ****************************************************************************
    *              Внутренние служебные функции
    ***************************************************************************/
    public int fill_mas() {          // Заполнение рабочих массивов

        int ii, k, l, ll;

        for (int i = 0; i < cn_len; i++) // Очистка индексных массивов от мусора
        {
            cn[i] = 0;
        }
        for (int j = 0; j < ln_len; j++) {
            ln[j] = 0;
        }

        // Производит проверку исходного списка для выявления элементов одной строки, имеющих одинаковые индексы
        k = 0;          // столбца или выходящих за пределы матрицы           
        for (int i = 1; i <= n; i++) {
            l = ll = 0;
            pnt_0[i] = k;
            for (int j = pnt0_0[i] + 1; j <= pnt0_1[i]; j++) // Заполнение строчно-упорядоченного списка: массивов a[], diag[], pnt_0[], pnt_1[].     
            {                
                if (cn0[j] > n) {
                    return TOO_LARGE_INDEX;
                }
                if (cn0[j] == i)
                {
                    if (ll == 0) {
                        diag[i] = a0[j];
                        ll = 1;
                    } else {
                        return TWO_EQUAL_ELEM_INDEXES;
                    }
                } else {
                    for (ii = 1; ii <= l; ii++) {
                        if (rings1[ii] == cn0[j]) {
                            return TWO_EQUAL_ELEM_INDEXES;
                        }
                    }
                    a[++k] = a0[j];
                    cn[k] = cn0[j];
                    rings1[++l] = cn0[j];
                }
            }
            pnt_1[i] = k;
            k += p;
            rings2[i] = 0;
        }
        cn_end = k;

        k = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = pnt_0[i] + 1; j <= pnt_1[i]; j++) {
                rings2[cn[j]]++;
            }
            pnt_2[i] = pnt_3[i] = k;                // Заполнение столбцово-упорядоченного списка: массивов ln[],pnt_2[], pnt_3[]
            k += rings2[i];
            k += p;
        }
        ln_end = k;
        for (int i = 1; i <= n; i++) {
            for (int j = pnt_0[i] + 1; j <= pnt_1[i]; j++) {
                ln[++pnt_3[cn[j]]] = i;
            }
            vac_0[i] = vac_1[i] = p;
            rings2[i] = i;
        }
        return OK;
    }

    public int factorization() {      // Непосредственно процедура разложения матрицы

        int ret_value;

        for (step = 1; step < n; step++) {
            ret_value = select();           // Выбор главного элемента
           
            if (ret_value != OK) {
                return ret_value;
            }
            ret_value = replace();          // Перестановка строк&столбцов
            
            if (ret_value != OK) {
                return ret_value;
            }
            ret_value = transform();        // Разложение матрицы
            
            if (ret_value != OK) {
                return ret_value;
            }
        }
        return OK;
    }

    // Определения служебных функций
    public int select() {               // Процедура выбора главного элемента

        int weight, beg_ring, end_ring, curr_elem_num;
        int clue;
        double buf;

        if (step == 1) // Инициализация колец на первом шаге 
        {
            for (int i = 1; i <= n; i++) {
                weight = pnt_1[i] - pnt_0[i] + pnt_3[i] - pnt_2[i];
                if (ring_adr[weight] == 0) {
                    ring_adr[weight] = i;
                } else {
                    beg_ring = ring_adr[weight];
                    end_ring = rings2[beg_ring];
                    rings1[end_ring] = i;
                    rings2[i] = end_ring;
                    rings2[beg_ring] = i;
                }
                price[i] = weight;
            }
        } else          // Корректировка колец на всех шагах кроме первого 
        {
            for (int l = pnt_0[step - 1] + 1; l <= pnt_1[step - 1]; l++) {
                int i = cn[l];
                weight = pnt_1[i] - pnt_0[i] + pnt_3[i] - pnt_2[i];
                if (price[i] != weight) // Если вес изменился, удалить элемент из старого кольца и включить в новое
                {
                    if (rings1[i] == 0) {
                        rings2[ring_adr[price[i]]] = rings2[i];
                    } else {
                        rings2[rings1[i]] = rings2[i];
                    }
                    if (ring_adr[price[i]] == i) {
                        ring_adr[price[i]] = rings1[i];
                    } else {
                        rings1[rings2[i]] = rings1[i];
                    }
                    rings1[i] = 0;
                    price[i] = weight;
                    if (ring_adr[weight] == 0) {
                        ring_adr[weight] = i;
                        rings2[i] = i;
                    } else {
                        beg_ring = ring_adr[weight];
                        end_ring = rings2[beg_ring];
                        rings1[end_ring] = i;
                        rings2[i] = end_ring;
                        rings2[beg_ring] = i;
                    }
                }
            }
        }

        weight = 0;
        curr_elem_num = 0;
        int i, j;
        do {                    // Выбор главного элемента из кольца c минимально разрешенным весом            
            clue = 0;            
            while (ring_adr[weight] == 0) {
                weight++;
                if (weight >= n) {
                    return BAD_MATRIX;
                }
            }
            j = ring_adr[weight];
            i = j;
            buf = Math.abs(diag[j]);
            while ((rings1[j] != 0) && (curr_elem_num < NUM_ELEM_SEARCH)) {
                j = rings1[j];
                if (buf < Math.abs(diag[j])) {
                    buf = Math.abs(diag[j]);
                    i = j;
                }
                curr_elem_num++;
            }
            if (buf <= delta) {
                weight++;
                clue = 1;
            }
        } while (clue == 1);

        s[step] = i;            // Элемент i выбран главным        

        if (rings1[i] == 0) {
            rings2[ring_adr[price[i]]] = rings2[i];
        } else {
            rings2[rings1[i]] = rings2[i];              // Исключение нового главного элемента из своего кольца            
        }
        if (ring_adr[price[i]] == i) {
            ring_adr[price[i]] = rings1[i];            
        } else {
            rings1[rings2[i]] = rings1[i];            
        }
        
        if (i == step) {
            return OK;
        }

        if (rings1[step] == 0) {
            rings2[ring_adr[price[step]]] = i;
        } else {
            rings2[rings1[step]] = i;            
        }
        rings2[i] = rings2[step];                       // Корректировка кольца, содержащего замещаемый элемент
        
        if (ring_adr[price[step]] == step) {
            ring_adr[price[step]] = i;
        } else {
            rings1[rings2[step]] = i;           
        }
        rings1[i] = rings1[step];

        j = price[step];
        price[step] = price[i];
        price[i] = j;

        return OK;
    }

    public int replace() {              // Преобразование подматрицы на шаге step: A = S A'S

        int weight_old, weight_new;
        int clue, ret_value;
        double buf;

        for (int i = pnt_0[step] + 1; i <= pnt_1[step]; i++) {
            for (int j = pnt_2[cn[i]] + 1; j <= pnt_3[cn[i]]; j++) {
                if (ln[j] == step) {
                    ln[j] = ln[pnt_3[cn[i]]--];
                    vac_1[cn[i]]++;
                    break;
                }
            }
        }

        int m = s[step];
        if (m == step) {
            return OK;
        }
        buf = diag[step];
        diag[step] = diag[m];
        diag[m] = buf;
        int l1 = 0;
        int l2 = n;
        clue = 0;
        weight_old = pnt_1[step] - pnt_0[step];
        weight_new = pnt_1[m] - pnt_0[m] + pnt_3[m] - pnt_2[m];
        for (int j = pnt_0[step] + 1; j <= pnt_1[step]; j++) {
            if (cn[j] != m) {
                if (cn[j] < m) {
                    tmpr[++l1] = a[j];
                    index[l1] = cn[j];
                } else {
                    tmpr[l2] = a[j];
                    index[l2--] = cn[j];
                }
            } else {
                buf = Math.abs(a[j] * a[j] / (diag[step] * diag[m]));
                if (buf > t2) {
                    a[pnt_0[step] + 1] = a[j];
                    cn[pnt_0[step] + 1] = m;
                    clue = 1;
                }
            }
        }
        pnt_1[step] = pnt_0[step] + clue;
        vac_0[step] += (int) (weight_old - clue);
        if (vac_0[step] < weight_new) {
            ret_value = rwr_cn(step, weight_new - vac_0[step]);
            if ((ret_value != OK) && (ret_value != CN_ARRANGEMENT_DONE)) {
                return ret_value;
            }
        }

        for (int i = pnt_3[m]; i > pnt_2[m]; i--) {
            for (int j = pnt_0[ln[i]] + 1; j <= pnt_1[ln[i]]; j++) {
                if (cn[j] == m) {
                    buf = Math.abs(a[j] * a[j] / (diag[step] * diag[ln[i]]));
                    if (buf > t2) {
                        a[++pnt_1[step]] = a[j];
                        cn[pnt_1[step]] = ln[i];
                        vac_0[step]--;
                    } else {
                        diag[step] *= (1 + Math.sqrt(buf));
                        diag[ln[i]] *= (1 + Math.sqrt(buf));
                    }

                    a[j] = a[pnt_1[ln[i]]];
                    cn[j] = cn[pnt_1[ln[i]]--];
                    vac_0[ln[i]]++;
                    break;
                }
            }
        }
        vac_1[m] += (int) (pnt_3[m] - pnt_2[m]);
        pnt_3[m] = pnt_2[m];

        for (int j = pnt_1[m]; j > pnt_0[m]; j--) {
            buf = Math.abs(a[j] * a[j] / (diag[step] * diag[cn[j]]));
            if (buf > t2) {
                a[++pnt_1[step]] = a[j];
                cn[pnt_1[step]] = cn[j];
                vac_0[step]--;
            } else {
                diag[step] *= (1 + Math.sqrt(buf));
                diag[cn[j]] *= (1 + Math.sqrt(buf));
            }

            for (int i = pnt_2[cn[j]] + 1; i <= pnt_3[cn[j]]; i++) {
                if (ln[i] == m) {
                    ln[i] = ln[pnt_3[cn[j]]--];
                    vac_1[cn[j]]++;
                    break;
                }
            }
        }
        vac_0[m] += (int) (pnt_1[m] - pnt_0[m]);
        pnt_1[m] = pnt_0[m];

        if (l1 > vac_1[m]) {
            ret_value = rwr_ln(m, l1 - vac_1[m]);
            if (ret_value != OK) {
                return ret_value;
            }
        }

        for (int k = 1; k <= l1; k++) {
            if (vac_0[index[k]] == 0) {
                ret_value = rwr_cn(index[k], 1);
                if ((ret_value != OK) && (ret_value != CN_ARRANGEMENT_DONE)) {
                    return ret_value;
                }
            }
            a[++pnt_1[index[k]]] = tmpr[k];
            cn[pnt_1[index[k]]] = m;
            vac_0[index[k]]--;
            ln[++pnt_3[m]] = index[k];
            index[k] = 0;
            vac_1[m]--;
        }

        if (n - l2 > vac_0[m]) {
            ret_value = rwr_cn(m, n - l2 - vac_0[m]);
            if ((ret_value != OK) && (ret_value != CN_ARRANGEMENT_DONE)) {
                return ret_value;
            }
        }
        for (int k = n; k > l2; k--) {
            a[++pnt_1[m]] = tmpr[k];
            cn[pnt_1[m]] = index[k];
            vac_0[m]--;
            if (vac_1[index[k]] == 0) {
                ret_value = rwr_ln(index[k], 1);
                if ((ret_value != OK)) {
                    return ret_value;
                }
            }
            ln[++pnt_3[index[k]]] = m;
            vac_1[index[k]]--;
            index[k] = 0;
        }
        return OK;
    }

    public int transform() {            // Шаг разложения по методу Холецкого

        int lenght;
        double buf, buffer;
        int ret_value;

        if (step == s[step]) // Если текущая строка выбрана главной, нужно проверить ее элементы на малость
        {
            for (int l = pnt_1[step]; l > pnt_0[step]; l--) {
                buffer = Math.abs(a[l] * a[l] / (diag[step] * diag[cn[l]]));
                if (buffer <= t2) {
                    a[l] = a[pnt_1[step]];
                    cn[l] = cn[pnt_1[step]--];
                    diag[step] *= (1 + Math.sqrt(buffer));
                    diag[cn[l]] *= (1 + Math.sqrt(buffer));
                }
            }
        }

        for (int l = pnt_0[step] + 1; l <= pnt_1[step]; l++) // Деление ведущей строки на ее диагональный элемент
        {
            tmpr[cn[l]] = a[l];
            index[cn[l]] = 1;

            a[l] /= diag[step];                 // Преобразование диагонали
            diag[cn[l]] -= tmpr[cn[l]] * a[l];  // Перезапись ведущей строки во временный массив
        }

        lenght = pnt_1[step] - pnt_0[step];

        for (int i = 1; i <= lenght; i++) // Внешний цикл по преобразуемым строкам активной подматрицы
        {
            int m = pnt_0[step] + i;
            int j = cn[m];
            for (int l = pnt_0[j] + 1; l <= pnt_1[j]; l++) {
                if (index[cn[l]] != 0) {
                    a[l] -= a[m] * tmpr[cn[l]];
                    index[cn[l]] = 0;
                }
            }
            for (int h = 1; h <= lenght; h++) {
                int l = pnt_0[step] + h;
                if (index[cn[l]] != 0) {
                    if (cn[l] > j) {
                        buf = -a[m] * tmpr[cn[l]];
                        if (vac_0[j] == 0) {
                            ret_value = rwr_cn(j, 1);
                            if (ret_value != OK) {
                                if (ret_value == CN_ARRANGEMENT_DONE) {
                                    l = pnt_0[step] + h;
                                    m = pnt_0[step] + i;
                                } else {
                                    return ret_value;
                                }
                            }
                        }
                        a[++pnt_1[j]] = buf;
                        cn[pnt_1[j]] = cn[l];
                        vac_0[j]--;
                        if (vac_1[cn[l]] == 0) {
                            ret_value = rwr_ln(cn[l], 1);
                            if (ret_value != OK) {
                                return ret_value;
                            }
                        }
                        ln[++pnt_3[cn[l]]] = j;
                        vac_1[cn[l]]--;
                    }
                } else {
                    index[cn[l]] = 1;
                }
            }
        }
        for (int l = pnt_0[step] + 1; l <= pnt_1[step]; l++) {
            index[cn[l]] = 0;
        }
        return OK;
    }

    public int rwr_cn(int line, int num) {        // Перезапись строки строчно-упоряд. списка в конец

        int ret_value;

        rwr_cn_num++;
        if (pnt_1[line] + vac_0[line] == cn_end) {
            if (cn_end + num + p < cn_len) {
                vac_0[line] += (int) (num + p);
                cn_end += (num + p);
                return OK;
            } else {
                ret_value = arr_cn(line, num);
                if (ret_value == OK) {
                    return CN_ARRANGEMENT_DONE;
                } else {
                    return ret_value;
                }
            }
        } else {
            if (cn_end + num + p + pnt_1[line] - pnt_0[line] + vac_0[line] < cn_len) {
                int end = cn_end;
                for (int i = pnt_0[line] + 1; i <= pnt_1[line]; i++) {
                    a[++cn_end] = a[i];
                    cn[cn_end] = cn[i];
                }
                pnt_0[line] = end;
                pnt_1[line] = cn_end;
                cn_end += (p + vac_0[line] + num);
                vac_0[line] += (int) (p + num);
                return OK;
            } else {
                ret_value = arr_cn(line, num);
                if (ret_value == OK) {
                    return CN_ARRANGEMENT_DONE;
                } else {
                    return ret_value;
                }
            }
        }
    }

    public int rwr_ln(int clm, int num) {  // Перезапись столбца столбцово-упоряд. списка в конец

        rwr_ln_num++;
        if (pnt_3[clm] + vac_1[clm] == ln_end) {
            if (ln_end + num + p < ln_len) {
                vac_1[clm] += (int) (num + p);
                ln_end += (num + p);
                return OK;
            } else {
                return arr_ln(clm, num);
            }
        } else {
            if (ln_end + num + p + pnt_3[clm] - pnt_2[clm] + vac_1[clm] < ln_len) {
                int end = ln_end;
                for (int i = pnt_2[clm] + 1; i <= pnt_3[clm]; i++) {
                    ln[++ln_end] = ln[i];
                }
                pnt_2[clm] = end;
                pnt_3[clm] = ln_end;
                ln_end += (p + vac_1[clm] + num);
                vac_1[clm] += (int) (p + num);
                return OK;
            } else {
                return arr_ln(clm, num);
            }
        }
    }

    public int arr_cn(int line, int num) {           // Сборка мусора по строчно-упоряд. списку

        int curr_pos, src_pos;
        int clue = 0;
        double[] line_a;

        arr_cn_num++;
        curr_pos = 0;
        src_pos = 1;
        int k = 0;

        line_a = new double[pnt_1[line] - pnt_0[line] + 1]; // Память под рабочий массив
        if (line_a == null) {
            return MEMORY_LACK;
        }

        for (int i = pnt_0[line] + 1; i <= pnt_1[line]; i++) {
            lc[++k] = cn[i];
            line_a[k] = a[i];
        }
        for (int j = 1; j <= n; j++) {
            if ((pnt_0[j] < pnt_1[j]) && (j != line)) {
                arr_mas[j] = cn[pnt_0[j] + 1];
                cn[pnt_0[j] + 1] = -j;
                clue++;
            }
        }

        while (cn[src_pos] >= 0) {
            src_pos++;
        }
        for (k = 1; k <= clue; k++) {
            int j = -cn[src_pos];
            cn[src_pos] = 0;
            pnt_0[j] = curr_pos;
            cn[++curr_pos] = arr_mas[j];
            a[curr_pos] = a[src_pos];
            while (++src_pos <= pnt_1[j]) {
                cn[++curr_pos] = cn[src_pos];
                a[curr_pos] = a[src_pos];
            }
            pnt_1[j] = curr_pos;
            if (k < clue) {
                while (cn[src_pos] >= 0) {
                    src_pos++;
                }
            } else {
                src_pos = cn_len;
            }
            int l = src_pos - curr_pos - 1;
            if (j <= step) {
                vac_0[j] = 0;
            } else {
                if (l < p) {
                    vac_0[j] = (int) l;
                } else {
                    vac_0[j] = p;
                }
                curr_pos += vac_0[j];
            }
        }
        for (int j = 1; j <= n; j++) {
            if ((pnt_0[j] == pnt_1[j]) && (j != line)) {
                pnt_0[j] = pnt_1[j] = curr_pos;
                if (j <= step) {
                    vac_0[j] = 0;
                } else {
                    vac_0[j] = p;
                }
                curr_pos += vac_0[j];
            }
        }

        k = pnt_1[line] - pnt_0[line];
        pnt_0[line] = curr_pos;
        for (int j = 1; j <= k; j++) {
            if (curr_pos < cn_len) {
                cn[++curr_pos] = lc[j];
                a[curr_pos] = line_a[j];
            } else {
                return TOO_FEW_ROOM_cn_MAS;
            }
        }
        pnt_1[line] = curr_pos;
        vac_0[line] += (int) (p + num);
        curr_pos += vac_0[line];
        cn_end = curr_pos;

        if ((double) cn_len / cn_end < RAT) {
            return TOO_FEW_ROOM_cn_MAS;
        } else {
            return OK;
        }
    }

    public int arr_ln(int clm, int num) {        // Сборка мусора по столбцово-упоряд. списку

        int curr_pos, src_pos;
        int clue;

        arr_ln_num++;
        curr_pos = 0;
        src_pos = 1;
        clue = 0;
        int k = 0;
        for (int i = pnt_2[clm] + 1; i <= pnt_3[clm]; i++) {
            lc[++k] = ln[i];
        }
        for (int j = step + 1; j <= n; j++) {
            if ((pnt_2[j] < pnt_3[j]) && (j != clm)) {
                arr_mas[j] = ln[pnt_2[j] + 1];
                ln[pnt_2[j] + 1] = -j;
                clue++;
            }
        }
        while (ln[src_pos] >= 0) {
            src_pos++;
        }
        for (k = 1; k <= clue; k++) {
            int j = -ln[src_pos];
            ln[src_pos] = 0;
            pnt_2[j] = curr_pos;
            ln[++curr_pos] = arr_mas[j];
            while ((++src_pos) <= pnt_3[j]) {
                ln[++curr_pos] = ln[src_pos];
            }
            pnt_3[j] = curr_pos;
            if (k < clue) {
                while (ln[src_pos] >= 0) {
                    src_pos++;
                }
            } else {
                src_pos = ln_len;
            }
            int l = src_pos - curr_pos - 1;
            if (l < p) {
                vac_1[j] = (int) l;
            } else {
                vac_1[j] = p;
            }
            curr_pos += vac_1[j];
        }

        for (int j = step + 1; j <= n; j++) {
            if ((pnt_2[j] == pnt_3[j]) && (j != clm)) {
                pnt_2[j] = pnt_3[j] = curr_pos;
                vac_1[j] = p;
                curr_pos += p;
            }
        }
        k = pnt_3[clm] - pnt_2[clm];
        pnt_2[clm] = curr_pos;
        for (int j = 1; j <= k; j++) {
            if (curr_pos < ln_len) {
                ln[++curr_pos] = lc[j];
            } else {
                return TOO_FEW_ROOM_ln_MAS;
            }
        }
        pnt_3[clm] = curr_pos;
        vac_1[clm] += (int) (p + num);
        curr_pos += vac_1[clm];
        ln_end = curr_pos;
        if ((double) ln_len / ln_end < RAT) {
            return TOO_FEW_ROOM_ln_MAS;
        }
        return OK;
    }
}
